#!/usr/bin/env python3
"""test_registration.py

Quick benchmark for rigid 6-DoF motion estimation methods (ICP, GICP)
using the synthetic point clouds generated by PointCloudZoetrope.

Run               :: python source/test_registration.py
Requires          :: open3d, numpy, matplotlib

The script will:
1. Generate a random point cloud.
2. Create a rotated version with a *known* Y-axis rotation.
3. Estimate the transform using ICP and GICP.
4. Compare the estimated transform with ground-truth and print errors.
"""
from __future__ import annotations

import numpy as np
from point_cloud import PointCloudZoetrope
from registration import (
    estimate_rigid_transform_icp,
    estimate_rigid_transform_gicp,
    evaluate_registration,
)

np.random.seed(42)  # For reproducibility

# -----------------------------------------------------------------------------
# Parameters
# -----------------------------------------------------------------------------
NUM_POINTS = 1000
RADIUS = 3.0
TRUE_ROT_Y_DEG = 25.0  # Ground-truth rotation about Y axis (degrees)
ICP_THRESHOLD = 0.1 * RADIUS  # max correspondence distance (~10 % of radius)


# -----------------------------------------------------------------------------
# Ground-truth helper
# -----------------------------------------------------------------------------

def rotation_y_matrix(deg: float) -> np.ndarray:
    rad = np.radians(deg)
    return np.array(
        [
            [np.cos(rad), 0.0, np.sin(rad)],
            [0.0, 1.0, 0.0],
            [-np.sin(rad), 0.0, np.cos(rad)],
        ]
    )


R_gt = rotation_y_matrix(TRUE_ROT_Y_DEG)
t_gt = np.zeros(3)  # No translation in this synthetic example

# -----------------------------------------------------------------------------
# 1. Generate synthetic data
# -----------------------------------------------------------------------------
print("Generating synthetic point clouds â€¦")
cloud = PointCloudZoetrope(num_points=NUM_POINTS, radius=RADIUS)
source_pts = cloud.points  # (N,3)
target_pts = cloud.rotate_y(TRUE_ROT_Y_DEG)  # Apply ground-truth rotation
print(f"Source / target points: {source_pts.shape[0]} / {target_pts.shape[0]}")

# -----------------------------------------------------------------------------
# 2. ICP (point-to-plane)
# -----------------------------------------------------------------------------
print("\n=== ICP (point-to-plane) ===")
res_icp = estimate_rigid_transform_icp(source_pts, target_pts, threshold=ICP_THRESHOLD)
metrics_icp = evaluate_registration(res_icp, R_gt, t_gt)
print("Transformation:\n", res_icp.transformation)
print("Metrics:")
for k, v in metrics_icp.items():
    print(f"  {k:>20}: {v:.6f}")

# -----------------------------------------------------------------------------
# 3. GICP
# -----------------------------------------------------------------------------
print("\n=== Generalized ICP ===")
res_gicp = estimate_rigid_transform_gicp(source_pts, target_pts, threshold=ICP_THRESHOLD)
metrics_gicp = evaluate_registration(res_gicp, R_gt, t_gt)
print("Transformation:\n", res_gicp.transformation)
print("Metrics:")
for k, v in metrics_gicp.items():
    print(f"  {k:>20}: {v:.6f}")

print("\nDone.") 